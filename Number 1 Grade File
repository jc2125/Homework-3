//d is the number of children per parent all throughout the program

/*function treeArray organizes the given array into an array that 
resembles the structure of a binary tree and makes the root of this
array be equal to the highest valued node in the tree*/ 

void treeArray(int arr[],int sizeOfArray, int d){
    int index = 2;
    int z = 2;
    int k = 2;
    int x = 0;
    int heapArray[sizeOfArray] = {0};
    heapArray[0] = arr[0];
    heapArray[1] = arr[1];
    for (x = 0; x < ((sizeOfArray/d)-1); x++)
    {
        int t = index;
        int p = 1;
        for (index = index;index <= t + d - 1;index++)
        {
            heapArray[index] = arr[((d* (z-1)) + p)];
            p++;
        }
        heapArray[index] = arr[k];
        index++;
        k++;
        z++;
    }
     if (d == 4 )
    {
        heapArray[7] = arr[9];
        heapArray[8] = arr[3];
        heapArray[9] = arr[4];
    }
    if (d == 5)
    {
        swap(heapArray[6],heapArray[7]);
        heapArray[7] = arr[3];
        heapArray[8] = arr[4];
        heapArray[9] = arr[5];
    }
    for (int w = 0; w < sizeOfArray; w++)
    {
        arr[w] = heapArray[w];
        cout << arr[w] << " ";
    }
    int Max = 0;
    for (int i = 0; i < sizeOfArray; i++)
    {
        if (arr[Max] < arr[i])
        {
            Max = i;
        }
    }
    swap (arr[Max], arr[0]);
}

/*function DaryHeap actually organizes this new array into an array where 
all of the parents are of greater value than all its children. It basically 
makes the tree array into a maxheap tree (before any deleting and sorting is
actually done though)*/

void DaryHeap(int arr[],int sizeOfArray,int d){
    int i = 1;
    if (d == 3)
    {
        for (int j = 0; j < ((sizeOfArray/d)-1) ; j++)
        {
            if ((arr[i+1] > arr[i+2])&&(arr[i+1] > arr[i+3]))
            {
                if (arr[i+1] > arr[i])
                {
                    swap (arr[i], arr[i+1]);
                }
            }
            else if ((arr[i+2] > arr[i+1])&&(arr[i+2] > arr[i+3]))
            {
                  if (arr[i+2] > arr[i])
                {
                    swap (arr[i], arr[i+1]);
                }
            }
            else if (arr[i+3] > arr[i+1]&&(arr[i+3] > arr[i+2]))
            {
                  if (arr[i+3] > arr[i])
                {
                    swap (arr[i], arr[i+3]);
                }
            }
            i = i + (d+1);
        }
    }
    else if (d == 4)
    {
        for (int t = 0; t < ((sizeOfArray/d)-1) ; t++)
        {
            if ((arr[i+1] > arr[i+2])&&(arr[i+1] > arr[i+3])&&(arr[i+1] > arr[i+4]))
            {
                   if (arr[i+1] > arr[i])
                {
                    swap (arr[i], arr[i+1]);
                }
            }
            else if ((arr[i+2] > arr[i+1])&&(arr[i+2] > arr[i+3])&&(arr[i+2] > arr[i+4]))
            {
                  if (arr[i+2] > arr[i])
                {
                    swap (arr[i], arr[i+2]);
                }
            }
            else if (arr[i+3] > arr[i+1]&&(arr[i+3] > arr[i+2])&&(arr[i+3] > arr[i+4]))
            {
                 if (arr[i+3] > arr[i])
                {
                    swap (arr[i], arr[i+3]);
                }
            }
            else if (arr[i+4] > arr[i+1]&&(arr[i+4] > arr[i+2])&&(arr[i+4] > arr[i+3]))
            {
                 if (arr[i+4] > arr[i])
                {
                    swap (arr[i], arr[i+4]);
                }
            }
            i = i + (d+1);
        }

    }
    else if (d == 5)
    {
        for (int w = 0; ((sizeOfArray/d)-1) ; w++)
        {
            if ((arr[i+1] > arr[i+2])&&(arr[i+1] > arr[i+3])&&(arr[i+1] > arr[i+4])&&(arr[i+1] > arr[i+5]))
            {
                if (arr[i+1] > arr[i])
                {
                    swap (arr[i], arr[i+1]);
                }
            }
            else if ((arr[i+2] > arr[i+1])&&(arr[i+2] > arr[i+3])&&(arr[i+2] > arr[i+4])&&(arr[i+2] > arr[i+5]))
            {
                if (arr[i+2] > arr[i])
                {
                    swap (arr[i], arr[i+2]);
                }
            }
            else if (arr[i+3] > arr[i+1]&&(arr[i+3] > arr[i+2])&&(arr[i+3] > arr[i+4])&&(arr[i+3] > arr[i+5]))
            {
                if (arr[i+3] > arr[i])
                {
                    swap (arr[i], arr[i+3]);
                }
            }
            else if (arr[i+4] > arr[i+1]&&(arr[i+4] > arr[i+2])&&(arr[i+4] > arr[i+3])&&(arr[i+4] > arr[i+5]))
            {
                if (arr[i+4] > arr[i])
                {
                    swap (arr[i], arr[i+4]);
                }
            }
            else if (arr[i+5] > arr[i+1]&&(arr[i+5] > arr[i+2])&&(arr[i+5] > arr[i+3])&&(arr[i+5] > arr[i+4]))
            {
                if (arr[i+5] > arr[i])
                {
                    swap (arr[i], arr[i+5]);
                }
            }
            i = i + (d+1);
        }
    }
}

/*Insert function inserts a value into the array, where this value becomes 
a child of a parent who does not have d number of children or any children
at all*/

void Insert(int k,int arrayLength, int arr[],int d){
arrayLength++;
arr[arrayLength-1] = k;
}

/*Swim function looks at this new tree with the inserted value and 
re-organizes it into a maxHeap binary tree such that if the inserted
child is greater than it's parent, they switch spots, and then if this
parent is now greater than the root, they switch spots with each other*/

void swim(int arr[],int arrayLength,int d){
arrayLength++;
if (arr[arrayLength-2] < arr[arrayLength-1])
{
    swap(arr[arrayLength-2],arr[arrayLength-1]);
    if (arr[0] < arr[arrayLength-2])
    {
        swap(arr[0],arr[arrayLength-2]);
    }
}
}

/*The delete max function finds the highest valued node (which will always be the 
root in a maxHeap) and swaps it with the most recent child. It then deletes what
was just the root and then reorganizes the tree such that the maximum valued node
in the tree will become the root once more. This delete function does the deletion 
and also the job of the sink function*/

void delMax(int arr[],int arrayLength,int d){
arrayLength++;
cout << "\n\nThe Largest Value in The Heap(which is going to be deleted) =\n" << arr[0] << endl;
swap(arr[0],arr[arrayLength-2]);
swap(arr[arrayLength-2],arr[arrayLength-1]);
arrayLength--;
}

/*This function takes the final tree array, and sorts the array by:
swapping the root with the last child, putting the root as the last
element in a empty array, then deleting the root from the tree array. 
it then reorganizes the tree into a maxHeap and continues to swap, copy, 
and delete until there are no elements in the original tree array thus
leaving the copy array in ascending sorted order based off of the values
that were in the original tree array*/

void daryHeapSort(int arr[],int arrayLength,int d){
int copyArray[arrayLength] = {0};
signed int t = arrayLength - 1;
while (t != -1)
{
swap(arr[0],arr[t]);
copyArray[t] = arr[t];
int Max = 0;
    for (int w = 0; w < t; w++)
    {
        if (arr[Max] < arr[w])
        {
            Max = w;
        }
    }
    swap (arr[Max], arr[0]);
t--;
}
cout << endl;
}
